# Do not edit this file
# Bright Photonics B.V. (c) 2024

import sys
import os
import httpx
import time
import base64
import json
from itertools import count
from typing import Any, Type, Union, List, Dict

from nazca.serializer import from_dict, to_dict
from nazca import Cell, Tables
from nazca import cellcache_util
from nazca.cellcache_util import ndcache
from nazca.interconnects import Interconnect
from nazca.util import load_nazca_cloud_connections, save_nazca_cloud_connections


credentials_path = os.path.expanduser(os.path.join("~", "nazca_cloud_credentials.json"))
server_configs = load_nazca_cloud_connections(credentials_path)
select = server_configs["select"]
connections = server_configs["connections"]
connection = connections[select]


cellcache_util.sqlite_flag = True
client = httpx.Client()
_ids = count(1)

base_url = ""
route = "/ligentec"
headers = {}
timeout = 10
buffer_time = 60


def token_not_expired():
    """Check if the token is not expired."""
    global token, port
    if token != "":
        if port != "":  # local server
            return True
        header, payload, signature = token.split(".")
        payload += "=" * (-len(payload) % 4)  # padding
        decoded_payload = base64.urlsafe_b64decode(payload).decode("utf-8")
        payload_dict = json.loads(decoded_payload)
        current_time = time.time() + buffer_time
        if current_time > payload_dict.get("exp", 0):
            if not refresh_token():
                print("Token is expired. " f"Cannot connect to the Nazca server at {base_url}.")
            else:
                return True
    return False


def refresh_token():
    """Use refresh token to get a new access token."""
    global token
    try:
        response = httpx.post(
            f"https://cloud.nazca-design.org/authentication/refresh_token",
            json={"refresh_token": connection["refresh_token"]},
            headers=headers,
            timeout=timeout,
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        message = response.json().get("message", False)
        if message:
            print(f"An HTTP error occurred: {message}")
            return False
        else:
            print(f"An HTTP error occurred: {err}")
            if hasattr(err, "response") and isinstance(err.response, httpx.Response):
                try:
                    error_message = err.response.json().get("error", "Unknown error")
                except ValueError:
                    error_message = "Unknown error"
            else:
                error_message = "Unknown error"
            print(f"Server error: {error_message}")
            raise ("Cannot refresh token.")
    except Exception as err:
        print(f"An error occurred: {err}")
        raise ("Cannot refresh token.")
    json_response = response.json()
    # json_response = {"refresh_token": "1234", "token": "ABCD"}
    token = f"Bearer {json_response.get('token', '')}"
    headers["Authorization"] = token
    refresh_token = json_response.get("refresh_token", "")
    connection["refresh_token"] = refresh_token
    connection["headers"] = headers
    server_configs["connections"][select] = connection
    save_nazca_cloud_connections(filename=credentials_path, server_configs=server_configs)
    return True


def check_server_health():
    """Check if the server is healthy and running, as well if the token is valid."""
    token_not_expired()
    try:
        response = httpx.get(f"{base_url}/health", headers=headers)
        response.raise_for_status()  # Raises an HTTPError if the status is 4xx, 5xx
    except httpx.HTTPStatusError as exc:
        if exc.response.status_code == 403:
            raise PermissionError(
                f"Access forbidden to the Nazca ligentec PDK server at {base_url}. Please check your permissions."
            ) from None
        else:
            raise ConnectionError(
                f"HTTP error occurred while connecting to the Nazca PDK server at {base_url}: {exc}"
            ) from None
    except httpx.RequestError as exc:
        raise ConnectionError(
            f"Cannot connect to the Nazca PDK server at {base_url}. Please check if the server is running."
        )
    print(f"Nazca {route[1:]} PDK server healthy at {base_url}.")
    return


def set_server(target: str):
    global base_url, headers, token, port
    conn = connection
    base_url = conn["base_url"]
    headers = conn["headers"]
    token = headers.get("Authorization", "")
    if token != "":
        token.replace("Bearer ", "")
    port = conn.get("port", "")
    if port != "":
        base_url = f"{base_url}:{port}"
    base_url = f"{base_url}{route}"
    try:
        check_server_health()
    except (PermissionError, ConnectionError) as e:
        print(e)
        sys.exit(1)


set_server(connection)


@ndcache()
def CrossingCompactBB() -> Type[Cell]:
    """Compact crossing.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/crossingcompactbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def CrossingCompact_TEBB() -> Type[Cell]:
    """Compact crossing, optimized for Transverse-Electric (TE) polarization.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/crossingcompact_tebb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def CrossingCompact_TMBB() -> Type[Cell]:
    """Compact crossing, optimized for Transverse-Magnetic (TM) polarization.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/crossingcompact_tmbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def CrossingLowLossBB() -> Type[Cell]:
    """Low-loss crossing.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/crossinglowlossbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def CrossingUltraCompactBB() -> Type[Cell]:
    """Ultra compact crossing.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/crossingultracompactbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def DCBB(L: float = 47.0) -> Type[Cell]:
    """Directional Coupler.

    Args:
        L (float): length of coupling Range in um [0.0 < 47.0 < 400.0]

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.post(f"{base_url}/dcbb", json={"L": L}, headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def DCpadP1(width: float = 150, height: float = 150, shape: str = "box") -> Type[Cell]:
    """Create a P1 metal bond pad in a box or a circular shape.

    Args:
        width (float): width of the metal in the pad or diameter in case of a circular shape
        height (float): height of the metal in the pad
        shape (str): shape of the metal pad 'circle' | 'box' (default)

    Returns:
        Cell: a pad element
    """
    token_not_expired()
    try:
        response = client.post(
            f"{base_url}/dcpadp1",
            json={"width": width, "height": height, "shape": shape},
            headers=headers,
            timeout=timeout,
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def ExSpotBB() -> Type[Cell]:
    """The ExSpot black box replaces the 2.5 μm mode field diameter (MFD) spot size converters (SSC) of X1 with advanced SMF28 MFD SSC. It is under development and its performance cannot be guaranteed.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/exspotbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def FGCBB() -> Type[Cell]:
    """Focused Grating Coupler (FGC) for fiber-chip coupling.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/fgcbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def InvertedTaperBB(width: float = 1.0) -> Type[Cell]:
    """An inverted taper to be used to couple in/out light from the chip with variable output IO width.

    Args:
        width (float): output IO width Range in um [0.6 < 1.0 < 3.0]

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.post(
            f"{base_url}/invertedtaperbb", json={"width": width}, headers=headers, timeout=timeout
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI1x2BB() -> Type[Cell]:
    """1x2 MMI with 50/50 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi1x2bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI2x2BB() -> Type[Cell]:
    """2x2 MMI with 50/50 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi2x2bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI2x2_7228BB() -> Type[Cell]:
    """2x2 MMI with 72/28 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi2x2_7228bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI2x2_8515BB() -> Type[Cell]:
    """2x2 MMI with 85/15 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi2x2_8515bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI2x2_9010BB() -> Type[Cell]:
    """2x2 MMI with 90/10 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi2x2_9010bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI2x2_9505BB() -> Type[Cell]:
    """2x2 MMI with 95/05 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi2x2_9505bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI3x3BB() -> Type[Cell]:
    """3x3 MMI  with 33/33/33 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi3x3bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def MMI4x4BB() -> Type[Cell]:
    """4x4 MMI with 25/25/25/25 splitting ratio.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/mmi4x4bb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def OViaBB() -> Type[Cell]:
    """Optical VIA between X1 and X2 waveguides.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/oviabb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def PBSBB() -> Type[Cell]:
    """Polarization Beam Splitter.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/pbsbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def PRBB() -> Type[Cell]:
    """Polarization Beam Rotator.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/prbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def TridentCouplerBB() -> Type[Cell]:
    """Trident Coupler to couple the light into and from the chip.

    Returns:
        Cell
    """
    token_not_expired()
    try:
        response = client.get(f"{base_url}/tridentcouplerbb", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def VIAarray(
    width: float = 0.36,
    height: float = 0.36,
    enclosure: float = 2.0,
    spacing: float = 0.36,
    nx: int = 10,
    ny: int = 10,
) -> Type[Cell]:
    """Create a VIA between the P1P and P1R layer.

    Args:
        width (float): width of the metal in the VIA
        height (float): height of the metal in the VIA
        enclosure (float): enclosure of VIA area by P1P and P1R
        spacing (float): VIA to VIA spacing
        nx (int): number of VIAs in x-direction
        ny (int): number of VIAs in y-direction

    Returns:
        Cell: a via element
    """
    token_not_expired()
    try:
        response = client.post(
            f"{base_url}/viaarray",
            json={
                "width": width,
                "height": height,
                "enclosure": enclosure,
                "spacing": spacing,
                "nx": nx,
                "ny": ny,
            },
            headers=headers,
            timeout=timeout,
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def cell_template(
    die_width: float = 5000, die_height: float = 5000, cellname: str = "LGT_MPW_FULL_CELL"
) -> Type[Cell]:
    """None"""
    token_not_expired()
    try:
        response = client.post(
            f"{base_url}/cell_template",
            json={"die_width": die_width, "die_height": die_height, "cellname": cellname},
            headers=headers,
            timeout=timeout,
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def export_gds(
    topcells: Type[Cell] = None,
    filename: str = "",
    flat: bool = False,
    clear: bool = False,
    bb: bool = False,
    uPDK: bool = False,
    md5: bool = False,
    submit: bool = False,
    bbpath: str = "",
    lgt_only: bool = True,
) -> None:
    """Export layout to gds file for all cells in <topcells>. Exports a layout using only LGT layers when lgt_only is
    set to True.

    Args:
        topcells (Cell | list of Cells): Cell(s) to export
            (default = None, which exports the 'nazca' default gds cell)
        filename (str): gds output filename (default = 'nazca_export.gds')
            The filename may include a path, in which case
            case the path becomes the base directory. Missing directories
            will be created.
        flat (bool): export flat gds, i.e. no hierarchy (default = False)
        clear (bool): clear mask layout between consecutive exports (default = True)
        bb (bool): Export design as a building block (default = False)'
        submit (bool): create a complete fileset for foundry submission (default=False)
        md5 (bool): create md5sum (default=False)
        bbpath (str): path to use to load a gds for bb=True generated modules (default="")
        lgt_only (bool): export layout to gds file using only Ligentec layers (default=True)

    Returns:
        None
    """
    token_not_expired()
    try:
        response = client.post(
            f"{base_url}/export_gds",
            json={
                "topcells": to_dict(data=topcells),
                "filename": filename,
                "flat": flat,
                "clear": clear,
                "bb": bb,
                "uPDK": uPDK,
                "md5": md5,
                "submit": submit,
                "bbpath": bbpath,
                "lgt_only": lgt_only,
            },
            headers=headers,
            timeout=timeout,
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def _synchronize_tables() -> dict:
    """Return data without deserializing."""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/synchronize_tables", headers=headers, timeout=timeout)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return response.json()


def synchronize_tables() -> Tables:
    """Function to synchronize PDK tables to the api client.

    Returns:
        nd.Tables: PDK tables
    """
    return from_dict(_synchronize_tables())


@ndcache()
def text(
    text: str = "Text",
    height: float = 32,
    strokewidth: float = 0,
    layer: str = "X1P",
    stretch: float = 1,
    align: str = "lb",
    linewidth: float = 1,
    instantiate: bool = False,
    box_layer: Any = None,
    box_buf: float = 0,
    cellname: str = "",
) -> Type[Cell]:
    """None"""
    token_not_expired()
    try:
        response = client.post(
            f"{base_url}/text",
            json={
                "text": text,
                "height": height,
                "strokewidth": strokewidth,
                "layer": layer,
                "stretch": stretch,
                "align": align,
                "linewidth": linewidth,
                "instantiate": instantiate,
                "box_layer": box_layer,
                "box_buf": box_buf,
                "cellname": cellname,
            },
            headers=headers,
            timeout=timeout,
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


@ndcache()
def unitcell(die_width: float = 8000, die_height: float = 4000, cellname: str = "UNIT_CELL_LIGENTEC") -> Cell:
    """Create a unitcell for HHI."""
    token_not_expired()
    try:
        response = client.post(
            f"{base_url}/unitcell",
            json={"die_width": die_width, "die_height": die_height, "cellname": cellname},
            headers=headers,
            timeout=timeout,
        )
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


synchronize_tables()


@ndcache()
def _get_afd():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/afd", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


afd = _get_afd()


@ndcache()
def _get_locai():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/locai", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


locai = _get_locai()


@ndcache()
def _get_nazca_logo():
    """get attribute Cell"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/nazca_logo", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


nazca_logo = _get_nazca_logo()


@ndcache()
def _get_p1():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/p1", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


p1 = _get_p1()


@ndcache()
def _get_p1_heater():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/p1_heater", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


p1_heater = _get_p1_heater()


@ndcache()
def _get_p1_route():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/p1_route", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


p1_route = _get_p1_route()


@ndcache()
def _get_pinlines():
    """get attribute dict"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/pinlines", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


pinlines = _get_pinlines()


@ndcache()
def _get_rib():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/rib", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


rib = _get_rib()


@ndcache()
def _get_technology():
    """get attribute str"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/technology", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


technology = _get_technology()


@ndcache()
def _get_x1():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/x1", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


x1 = _get_x1()


@ndcache()
def _get_x1_cband():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/x1_cband", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


x1_cband = _get_x1_cband()


@ndcache()
def _get_x1_oband():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/x1_oband", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


x1_oband = _get_x1_oband()


@ndcache()
def _get_x2():
    """get attribute Interconnect"""
    token_not_expired()
    try:
        response = client.get(f"{base_url}/x2", headers=headers)
        response.raise_for_status()
    except httpx.HTTPError as err:
        print(f"An HTTP error occurred: {err}")
        if hasattr(err, "response") and isinstance(err.response, httpx.Response):
            try:
                error_message = err.response.json().get("error", "Unknown error")
            except ValueError:
                error_message = "Unknown error"
        else:
            error_message = "Unknown error"
        print(f"Server error: {error_message}")
        return None
    except Exception as err:
        print(f"An error occurred: {err}")
        return None
    return from_dict(data=response.json())


x2 = _get_x2()
if __name__ == "__main__":
    check_server_health()
